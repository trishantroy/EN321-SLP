#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <time.h>

#include "vulnerability_analysis_functions.h"

namespace vaf = vulnerability_analysis_functions;

vaf::bus_system stevenson_example;
vaf::directed_graph example_1, example_2;
vaf::directed_graph ieee_39_bus_system;
vaf::directed_graph ieee_118_bus_system;

std::string ieee_39_bus_system_file = "data_files/IEEE39_Bus_Line_Data.csv";
std::string ieee_39_bus_system_line_centrality_file = "data_files/ieee_39_bus_system_line_centrality.csv";
std::string ieee_39_bus_system_node_centrality_file = "data_files/ieee_39_bus_system_node_centrality.csv";

std::string ieee_118_bus_system_file = "data_files/IEEE118_Bus_Line_Data.csv";
// std::string ieee_118_bus_system_file = "data_files/ieee118_line_data.csv";
std::string ieee_118_bus_system_gen_data = "data_files/IEEE118_Bus_Gen_Data.csv";
std::string ieee_118_bus_system_load_data = "data_files/IEEE118_Bus_Load_Data.csv";
std::string ieee_118_bus_system_line_centrality_file = "data_files/ieee_118_bus_system_line_centrality.csv";
std::string ieee_118_bus_system_node_centrality_file = "data_files/ieee_118_bus_system_node_centrality.csv";

std::string attacks_data = "data_files/attacks_data.csv";

std::ofstream output_file1, output_file2, output_file3;

vaf::directed_graph example;

void initialize_files(){
	// output_file1.open(ieee_39_bus_system_line_centrality_file.c_str(), std::ios::out);
	// output_file2.open(ieee_39_bus_system_node_centrality_file.c_str(), std::ios::out);
	output_file1.open(ieee_118_bus_system_line_centrality_file.c_str(), std::ios::out);
	output_file2.open(ieee_118_bus_system_node_centrality_file.c_str(), std::ios::out);
	output_file3.open(attacks_data.c_str(), std::ios::out);
}

void define_bus_system(){
	stevenson_example.number_of_buses = 4;
}

void get_osos_graph(){
	example_1.generate_vertices_and_empty_edges(7);

	example_1.edge_capacities[0][1] = 17.1;
	example_1.edge_capacities[1][2] = 7.1;
	example_1.edge_capacities[1][3] = 10.1;
	example_1.edge_capacities[2][4] = 6.1;
	example_1.edge_capacities[2][6] = 3.1;
	example_1.edge_capacities[3][4] = 7.1;
	example_1.edge_capacities[3][5] = 5.1;
	example_1.edge_capacities[4][5] = 2.1;
	example_1.edge_capacities[4][6] = 4.1;
	example_1.edge_capacities[5][6] = 8.1;
}

void get_msms_graph(){
	example_2.generate_vertices_and_empty_edges(10);

	example_2.edge_capacities[0][2] = 18;
	example_2.edge_capacities[1][4] = 15;
	example_2.edge_capacities[2][3] = 6;
	example_2.edge_capacities[2][4] = 8;
	example_2.edge_capacities[3][5] = 3;
	example_2.edge_capacities[3][7] = 6;
	example_2.edge_capacities[4][5] = 7;
	example_2.edge_capacities[4][6] = 5;
	example_2.edge_capacities[5][6] = 2;
	example_2.edge_capacities[5][7] = 4;
	example_2.edge_capacities[5][9] = 9;
	example_2.edge_capacities[6][7] = 8;
	example_2.edge_capacities[6][8] = 7;
}

void get_ieee39_bus_system_data(){
	ieee_39_bus_system.generate_vertices_and_empty_edges(39);

	int edges = 0;
	std::ifstream input_file;
	std::vector<double> row;
	std::string line, word, temp;

	input_file.open(ieee_39_bus_system_file.c_str());
	std::getline(input_file,line);

	while(std::getline(input_file, line)){
		std::stringstream s(line);
		std::cout << "Line: " << line << std::endl;
		row.clear();
		while (std::getline(s, word, ',')){
			row.push_back(std::atof(word.c_str()));
		}
		ieee_39_bus_system.edge_capacities[row[0] - 1][row[1] - 1] = row[7];
		edges++;
	}
	ieee_39_bus_system.no_of_edges = edges;

	ieee_39_bus_system.sources.push_back(39);
	ieee_39_bus_system.sources.push_back(31);
	ieee_39_bus_system.sources.push_back(32);
	ieee_39_bus_system.sources.push_back(33);
	ieee_39_bus_system.sources.push_back(34);
	ieee_39_bus_system.sources.push_back(35);
	ieee_39_bus_system.sources.push_back(36);
	ieee_39_bus_system.sources.push_back(37);
	ieee_39_bus_system.sources.push_back(38);
	ieee_39_bus_system.sources.push_back(30);

	ieee_39_bus_system.sinks.push_back(39);
	ieee_39_bus_system.sinks.push_back(7);
	ieee_39_bus_system.sinks.push_back(8);
	ieee_39_bus_system.sinks.push_back(4);
	ieee_39_bus_system.sinks.push_back(3);
	ieee_39_bus_system.sinks.push_back(25);
	ieee_39_bus_system.sinks.push_back(18);
	ieee_39_bus_system.sinks.push_back(31);
	ieee_39_bus_system.sinks.push_back(26);
	ieee_39_bus_system.sinks.push_back(12);
	ieee_39_bus_system.sinks.push_back(27);
	ieee_39_bus_system.sinks.push_back(15);
	ieee_39_bus_system.sinks.push_back(16);
	ieee_39_bus_system.sinks.push_back(20);
	ieee_39_bus_system.sinks.push_back(28);
	ieee_39_bus_system.sinks.push_back(24);
	ieee_39_bus_system.sinks.push_back(21);
	ieee_39_bus_system.sinks.push_back(23);
	ieee_39_bus_system.sinks.push_back(20);
}

void get_ieee118_bus_system_data(){
	bool skip_next_row = false;
	ieee_118_bus_system.generate_vertices_and_empty_edges(118);

	int edges = 0;
	std::ifstream input_file;
	std::vector<double> row;
	std::string line, word, temp;

	// Load line data
	input_file.open(ieee_118_bus_system_file.c_str());
	std::getline(input_file,line);

	while(std::getline(input_file, line)){
		if(skip_next_row){
			skip_next_row = false;
			continue;
		}
		std::stringstream s(line);
		// std::cout << "Line: " << line << std::endl;
		row.clear();
		/*while (std::getline(s, word, ',')){
			if(word.c_str() == "C"){
				std::cout << "Skipping row" << std::endl;
				skip_next_row = true;
			}
			row.push_back(atof(word.c_str()));
		}
		ieee_118_bus_system.edge_capacities[row[0] - 1][row[3] - 1] = row[17];
		std::cout << "Line: " << row[0] << ", " << row[3] << ", " << row[17] << std::endl;
		edges++;*/
		while (std::getline(s, word, ',')){
			row.push_back(atof(word.c_str()));
		}
		if(ieee_118_bus_system.edge_capacities[row[0] - 1][row[1] - 1] == 0){
			ieee_118_bus_system.edge_capacities[row[0] - 1][row[1] - 1] = row[6];
			ieee_118_bus_system.no_of_edges++;
		}
		else
			ieee_118_bus_system.edge_capacities[row[0] - 1][row[1] - 1] += row[6];
		std::cout << "Line: " << row[0] << ", " << row[1] << ", " << row[6] << std::endl;
		edges++;
	}
	// ieee_118_bus_system.no_of_edges = 186;
	input_file.close();

	// Load generator bus data
	input_file.open(ieee_118_bus_system_gen_data.c_str());
	std::getline(input_file,line);

	while(std::getline(input_file, line)){
		std::stringstream s(line);
		std::cout << "Gen: " << line << std::endl;
		row.clear();
		while (std::getline(s, word, ',')){
			row.push_back(std::atoi(word.c_str()));
		}
		ieee_118_bus_system.sources.push_back(row[0]);
	}
	// ieee_118_bus_system.sources.push_back(1);
	input_file.close();

	// Load load bus data
	input_file.open(ieee_118_bus_system_load_data.c_str());
	std::getline(input_file,line);

	while(std::getline(input_file, line)){
		std::stringstream s(line);
		std::cout << "Load: " << line << std::endl;
		row.clear();
		while (std::getline(s, word, ',')){
			row.push_back(std::atoi(word.c_str()));
		}
		ieee_118_bus_system.sinks.push_back(row[0]);
	}
	input_file.close();
}

std::vector<int> edge_number_to_edge(int n){
	std::vector<int> ans;
	int k = 0;
	for(int i = 0; i < example.vertices.size(); i++){
		// std::cout << "HEY" << std::endl;
		for(int j = 0; j < example.vertices.size(); j++){
			// std::cout << "HEY2" << std::endl;
			if(example.edge_capacities[i][j] != 0){
				k++;
				if(k == n){
					ans.push_back(i);
					ans.push_back(j);
					return ans;
				}
			}
		}
	}
	std::cout << "ERROR" << std::endl;
	return ans;
}

int main(int argc, char const *argv[]){
	std::cout << "Starting...." << std::endl;
	initialize_files();
	// define_bus_system();
	// get_osos_graph();
	// get_msms_graph();
	
	get_ieee118_bus_system_data();
	example = ieee_118_bus_system;
	
	// example.find_sources_and_sinks();
	// example.find_no_of_edges();
	
	std::vector<std::vector<double> > sum_of_edge_flows(example.vertices.size(),std::vector<double>(example.vertices.size(),0));
	std::vector<std::vector<double> > line_centralities(example.vertices.size(),std::vector<double>(example.vertices.size(),0));

	double max_flows;

	for(int i = 0; i < example.sources.size(); i++){
		for(int j = 0; j < example.sinks.size(); j++){
			if(example.sources[i] != example.sinks[j]){
				std::cout << "Source, Sink: " << example.sources[i] << ", " << example.sinks[j] << std::endl;
				vaf::maxflow_matrix ff_matrix = example.find_maximum_flow(example.sources[i],example.sinks[j]);
				ff_matrix.print();
				max_flows += ff_matrix.maxflow;
				for(int m = 0; m < sum_of_edge_flows.size(); m++){
					for(int n = 0; n < sum_of_edge_flows[m].size(); n++){
						sum_of_edge_flows[m][n] += ff_matrix.edges_flow[m][n];
					}
				}
			}
			else{
				std::cout << "Same source and sink: " << example.sources[i] << ", " << example.sinks[j] << std::endl;
			}
		}
	}
	
	// Centrality Index Calculations
	std::cout << "----------Centrality indices--------" << std::endl;
	for(int i = 0; i < sum_of_edge_flows.size(); i++){
		for(int j = 0; j < sum_of_edge_flows[i].size(); j++){
			if(example.edge_capacities[i][j] != 0){
				line_centralities[i][j] = sum_of_edge_flows[i][j]/max_flows;
				std::cout << "Edge " << (i+1) << " to " << (j+1) << ": " << line_centralities[i][j] << std::endl;
			}
		}
	}
	std::cout << "-------------------------------------" << std::endl;
	
	// Node Centrality Calculations
	std::cout << "----------Node Centralities----------" << std::endl;
	std::vector<double> node_centralities(example.vertices.size(), 0);
	for(int i = 0; i < sum_of_edge_flows.size(); i++){
		node_centralities[i] = *std::max_element(sum_of_edge_flows[i].begin(), sum_of_edge_flows[i].end())/max_flows;
		std::cout << "Node: " << (i+1) << ", " << node_centralities[i] << std::endl;
		output_file2 << (i+1) << "," << node_centralities[i] << "\n";
	}
	std::cout << "-------------------------------------" << std::endl;

	// Ranking of edges and writing to file
	int rank_no = example.no_of_edges;
	std::pair<double, std::pair<int, int> > rank_edges[rank_no];
	int k = 0;
	for(int i = 0; i < sum_of_edge_flows.size(); i++){
		for(int j = 0; j < sum_of_edge_flows[i].size(); j++){
			if(example.edge_capacities[i][j] != 0){
				rank_edges[k] = std::make_pair(line_centralities[i][j], std::make_pair(i+1,j+1));
				k++;
			}
		}
	}

	std::sort(rank_edges, rank_edges + rank_no);
	std::cout << "-----Centrality indices' (Ranked)----" << std::endl;
	std::cout << "Rank no: " << rank_no << std::endl;
	for(int i = rank_no-1; i >= 0; i--){
		std::cout << "Edge " << (rank_no-i) << ", " << rank_edges[i].second.first << "-" << rank_edges[i].second.second << " :: " << rank_edges[i].first;
		output_file1 << rank_edges[i].second.first << "," << rank_edges[i].second.second << "," << rank_edges[i].first << "\n";
		if(example.is_source(rank_edges[i].second.first))
			std::cout << " SOURCE";
		if(example.is_sink(rank_edges[i].second.second))
			std::cout << " SINK";
		std::cout << std::endl;
	}
	std::cout << "------------------------------------" << std::endl;

	// Effect of random attacks

	vaf::directed_graph random_attacked_system;
	std::vector<double> attack_maxflow_percent;

	double max_flows2;
	for(int j = 0; j < 5; j++){
		random_attacked_system = ieee_118_bus_system;
		output_file3 << "Random,";
		srand(time(0));
		for(int i = 0; i < 10; i++){
			max_flows2 = 0;
			int a = rand()%rank_no;
			std::cout << "ATTACK AT: " << a << std::endl;
			std::vector<int> edge = edge_number_to_edge(a);
			random_attacked_system.edge_capacities[edge[0]][edge[1]] = 0;

			for(int i = 0; i < random_attacked_system.sources.size(); i++){
				for(int j = 0; j < random_attacked_system.sinks.size(); j++){
					if(random_attacked_system.sources[i] != random_attacked_system.sinks[j]){
						// std::cout << "Source, Sink: " << random_attacked_system.sources[i] << ", " << random_attacked_system.sinks[j] << std::endl;
						vaf::maxflow_matrix ff_matrix = random_attacked_system.find_maximum_flow(random_attacked_system.sources[i],random_attacked_system.sinks[j]);
						// ff_matrix.print();
						max_flows2+= ff_matrix.maxflow;
						for(int m = 0; m < sum_of_edge_flows.size(); m++){
							for(int n = 0; n < sum_of_edge_flows[m].size(); n++){
								sum_of_edge_flows[m][n] += ff_matrix.edges_flow[m][n];
							}
						}
					}
					else{
						// std::cout << "Same source and sink: " << random_attacked_system.sources[i] << ", " << random_attacked_system.sinks[j] << std::endl;
					}
				}
			}
			std::cout << "Max flow: " << max_flows2 << ", " << max_flows2/max_flows*100 << std::endl;
			attack_maxflow_percent.push_back(max_flows2/max_flows*100);
			output_file3 << max_flows2/max_flows*100 << ",";
		}
		output_file3 << "\n";
	}

	vaf::directed_graph target_attacked_system = ieee_118_bus_system;
	std::vector<double> targeted_attack_maxflow_percent;

	double max_flows3;
	output_file3 << "Targeted,"; 
	for(int i = rank_no-1; i > rank_no-11; i--){
		max_flows3 = 0;
		std::cout << rank_edges[i].second.first << ", " << rank_edges[i].second.second << std::endl;
		// std::cout << "Prev. edge_capacity " << target_attacked_system.edge_capacities[rank_edges[i].second.first-1][rank_edges[i].second.second-1] << std::endl;
		target_attacked_system.edge_capacities[rank_edges[i].second.first-1][rank_edges[i].second.second-1] = 0;

		for(int i = 0; i < target_attacked_system.sources.size(); i++){
			for(int j = 0; j < target_attacked_system.sinks.size(); j++){
				if(target_attacked_system.sources[i] != target_attacked_system.sinks[j]){
					// std::cout << "Source, Sink: " << target_attacked_system.sources[i] << ", " << target_attacked_system.sinks[j] << std::endl;
					vaf::maxflow_matrix ff_matrix = target_attacked_system.find_maximum_flow(target_attacked_system.sources[i],target_attacked_system.sinks[j]);
					// ff_matrix.print();
					max_flows3+= ff_matrix.maxflow;
					for(int m = 0; m < sum_of_edge_flows.size(); m++){
						for(int n = 0; n < sum_of_edge_flows[m].size(); n++){
							sum_of_edge_flows[m][n] += ff_matrix.edges_flow[m][n];
						}
					}
				}
			}
		}
		std::cout << "Max flow: " << max_flows3 << ", " << max_flows3/max_flows*100 << std::endl;
		targeted_attack_maxflow_percent.push_back(max_flows3/max_flows*100);
		output_file3 << max_flows3/max_flows*100 << ",";
	}
	output_file3 << "\n";

	return 0;
}