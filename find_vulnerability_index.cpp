#include <iostream>
#include <string>
#include <algorithm>

#include "vulnerability_analysis_functions.h"

namespace vaf = vulnerability_analysis_functions;

vaf::bus_system stevenson_example;
vaf::directed_graph example_1, example_2;

void define_bus_system(){
	stevenson_example.number_of_buses = 4;
}

void get_osos_graph(){
	example_1.generate_vertices_and_empty_edges(7);

	example_1.edge_capacities[0][1] = 17.1;
	example_1.edge_capacities[1][2] = 7.1;
	example_1.edge_capacities[1][3] = 10.1;
	example_1.edge_capacities[2][4] = 6.1;
	example_1.edge_capacities[2][6] = 3.1;
	example_1.edge_capacities[3][4] = 7.1;
	example_1.edge_capacities[3][5] = 5.1;
	example_1.edge_capacities[4][5] = 2.1;
	example_1.edge_capacities[4][6] = 4.1;
	example_1.edge_capacities[5][6] = 8.1;
}

void get_msms_graph(){
	example_2.generate_vertices_and_empty_edges(10);

	example_2.edge_capacities[0][2] = 18;
	example_2.edge_capacities[1][4] = 15;
	example_2.edge_capacities[2][3] = 6;
	example_2.edge_capacities[2][4] = 8;
	example_2.edge_capacities[3][5] = 3;
	example_2.edge_capacities[3][7] = 6;
	example_2.edge_capacities[4][5] = 7;
	example_2.edge_capacities[4][6] = 5;
	example_2.edge_capacities[5][6] = 2;
	example_2.edge_capacities[5][7] = 4;
	example_2.edge_capacities[5][9] = 9;
	example_2.edge_capacities[6][7] = 8;
	example_2.edge_capacities[6][8] = 7;
}

int main(int argc, char const *argv[]){
	// define_bus_system();
	get_osos_graph();
	get_msms_graph();

	vaf::directed_graph example = example_2;
	example.find_sources_and_sinks();
	example.find_no_of_edges();

	std::vector<std::vector<double> > sum_of_edge_flows(example.vertices.size(),std::vector<double>(example.vertices.size(),0));
	double max_flows;

	for(int i = 0; i < example.sources.size(); i++){
		for(int j = 0; j < example.sinks.size(); j++){
			std::cout << "Source, Sink: " << example.sources[i] << ", " << example.sinks[j] << std::endl; 
			vaf::maxflow_matrix ff_matrix = example.find_maximum_flow(example.sources[i],example.sinks[j]);
			ff_matrix.print();
			max_flows += ff_matrix.maxflow;
			for(int m = 0; m < sum_of_edge_flows.size(); m++){
				for(int n = 0; n < sum_of_edge_flows[m].size(); n++){
					sum_of_edge_flows[m][n] += ff_matrix.edges_flow[m][n];
				}
			}
		}
	}
	
	// Centrality Index Calculations
	std::cout << "----------Centrality indices'--------" << std::endl;
	for(int i = 0; i < sum_of_edge_flows.size(); i++){
		for(int j = 0; j < sum_of_edge_flows[i].size(); j++){
			if(example.edge_capacities[i][j] != 0)
				std::cout << "Edge " << (i+1) << " to " << (j+1) << ": " << sum_of_edge_flows[i][j]/max_flows << std::endl;
		}
	}
	std::cout << "-------------------------------------" << std::endl;
	
	// Ranking of edges
	int rank_no = example.no_of_edges;
	std::pair<double, std::pair<int, int> > rank_edges[rank_no];
	int k = 0;
	for(int i = 0; i < sum_of_edge_flows.size(); i++){
		for(int j = 0; j < sum_of_edge_flows[i].size(); j++){
			if(example.edge_capacities[i][j] != 0){
				rank_edges[k] = std::make_pair(sum_of_edge_flows[i][j]/max_flows, std::make_pair(i+1,j+1));
				k++;
			}
		}
	}

	std::sort(rank_edges, rank_edges + rank_no);
	std::cout << "-----Centrality indices' (Ranked)----" << std::endl;
	std::cout << rank_no << std::endl;
	for(int i = rank_no-1; i >= 0; i--){
		std::cout << "Edge " << rank_edges[i].second.first << "-" << rank_edges[i].second.second << " :: " << rank_edges[i].first;
		if(example.is_source(rank_edges[i].second.first))
			std::cout << " SOURCE";
		else if(example.is_sink(rank_edges[i].second.second))
			std::cout << " SINK";
		std::cout << std::endl;
	}
	std::cout << "------------------------------------" << std::endl;

	return 0;
}