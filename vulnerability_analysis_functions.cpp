#include <iostream>
#include <algorithm>

#include "vulnerability_analysis_functions.h"
#include "ford_fulkerson_functions.h"

namespace vulnerability_analysis_functions{
	bus_system::bus_system(){

	}
	void bus_system::calculate_vulnerability_indices(){
	}

	directed_edge::directed_edge(int s, int e, double c){
		start = s;
		end = e;
		capacity = c;
	}

	void maxflow_matrix::print(){
		std::cout << "--------Maximum flow: " << maxflow << "---------" << std::endl;
		std::cout << "Flow through edges in max flow condition: " << std::endl;
		for(int i = 0; i < edges_flow.size(); i++){
			for(int j = 0; j < edges_flow[i].size(); j++){
				if(edges_flow[i][j] != 0)
					std::cout << "Node " << (i+1) << " to Node " << (j+1) << " with flow " << edges_flow[i][j] <<std::endl;
			}
		}
		std::cout << "------------------------------------" << std::endl;
	}

	void directed_graph::generate_vertices_and_empty_edges(int n){
		std::vector<double> empty_row(n,0);
		for(int i = 1; i <= n; i++){			
			vertices.push_back(i);
			edge_capacities.push_back(empty_row);
		}
	}

	maxflow_matrix directed_graph::find_maximum_flow(int s, int e){
		// std::cout << "Entering find_maximum_flow()" << std::endl;
		ford_fulkerson_functions::maxflow_resmatrix ff_resmatrix = ford_fulkerson_functions::FordFulkerson(edge_capacities, s-1, e-1);

		maxflow_matrix ans;
		ans.maxflow = ff_resmatrix.maxflow;
		ans.edges_flow = std::vector<std::vector<double> >(ff_resmatrix.resmatrix.size(),std::vector<double>(ff_resmatrix.resmatrix.size(),0));

		for(int i = 0; i < edge_capacities.size(); i++){
			for(int j = 0; j < edge_capacities[i].size(); j++){
				if(edge_capacities[i][j] != 0){
					ans.edges_flow[i][j] = ff_resmatrix.resmatrix[j][i];
				}
			}
		}
		return ans;
	}

	int directed_graph::calculate_in_degree(int s){
		int ans = 0;		
		for(int j = 0; j < edge_capacities.size(); j++){
			if(edge_capacities[j][s] != 0){
				ans++;
			}
		}
		return ans;
	}

	int directed_graph::calculate_out_degree(int s){
		int ans = 0;
		for(int j = 0; j < edge_capacities.size(); j++){
			if(edge_capacities[s][j] != 0){
				ans++;
			}
		}
		return ans;
	}

	bool directed_graph::is_source(int s){
		for(int i = 0; i < sources.size(); i++){
			if(sources[i] == s)
				return true;
		}
		return false;
	}

	bool directed_graph::is_sink(int s){
		for(int i = 0; i < sinks.size(); i++){
			if(sinks[i] == s)
				return true;
		}
		return false;
	}

	void directed_graph::find_sources_and_sinks(){
		for(int i = 0; i < vertices.size(); i++){
			int m = calculate_in_degree(i);
			int n = calculate_out_degree(i);
			if((n > 0) && (m == 0)){
				sources.push_back(i+1);
				// std::cout << "Source: " << (i+1) << std::endl;
			}
			if((m > 0) && (n == 0)){
				sinks.push_back(i+1);
				// std::cout << "Sink: " << (i+1) << std::endl;
			}
		}
	}

	void directed_graph::find_no_of_edges(){
		int n = 0;
		for(int i = 0; i < edge_capacities.size(); i++){
			for(int j = 0; j < edge_capacities[i].size(); j++){
				if(edge_capacities[i][j] != 0)
					n++;
			}
		}
		no_of_edges = n;
	}
};